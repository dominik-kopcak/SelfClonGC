initialize()
{
	defineConstant("k", 91.63); // k chosen such that mean h is 0.2
	defineConstant("R", GC_rate);
	defineConstant("MU", 4e-9);
	defineConstant("meanLength", lambda);
	defineConstant("L", 25000000); // for convenience, haploid genome length is defined at the beginning
	
	initializeSLiMModelType("nonWF");
	initializeMutationType("m1", 0, "g", -0.01, 0.2); // 0.01 is the mean, 0.2 is the shape parameter
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	initializeMutationRate(MU); // so that #########################################################
	initializeRecombinationRate(R); // it actually represent GC, no recombination is heppening
	m1.convertToSubstitution=T;
}

// GC stands for gene conversion: short track on one chromosome which got replaced from another chromosome
// draw of GC tracts length mimics SLiM manual on DSB model of recombination

function (integer)giveGCBreakpoints(void){

	GC_number = rpois(1, R*L);
	
	if (GC_number<1){
	
		return integer(0);
	}
	
	else {
		GC_breaks = rdunif(GC_number, 0 , L-1);
		
		GC_left_part = rgeom(GC_number, 2/meanLength);
		GC_right_part = rgeom(GC_number, 2/meanLength);
		
		GC_track_beginning = GC_breaks - GC_left_part;
		GC_track_end = GC_breaks + GC_right_part;
			
		underrangeIndex = which(GC_track_beginning < 0);
		GC_track_beginning[underrangeIndex] = 0;
		
		overrangeIndex = which(GC_track_end > L-1);
		GC_track_end[overrangeIndex] = -1; // so that these are later easily detected and removed
		
		GC_breakpoints = c(GC_track_beginning, GC_track_end);
		return GC_breakpoints;
	}
}

reproduction(){

	K = sim.getValue("K");
	inds = p1.individuals;
	fitness = p1.cachedFitness(NULL);
	parents = sample(inds, K, replace=T, weights=fitness);
	
	for (parent in parents){
	
	if (rdunif(1,0,1)==1){
	
			gA = parent.genome1;
			gB = parent.genome2;
		}
		
		else{
		
			gA = parent.genome2;
			gB = parent.genome1;
		}
		
		GCBreakpoints = giveGCBreakpoints();
		
		genome1_Breakpoints = integer(0);
		genome2_Breakpoints = GCBreakpoints;
		
		// removes the -1 value, so that the end of chromosome does not switch back
		genome2_Breakpoints = genome2_Breakpoints[genome2_Breakpoints!=-1];

		// sorting done by SLiM automatically
		p1.addRecombinant(gA, gB, genome1_Breakpoints, gB, gA, genome2_Breakpoints);
				
		self.active = 0;
	}
}


1 early(){

	sim.setValue("K", 5000);
	sim.addSubpop("p1", sim.getValue("K"));
}

early() {

	meanFitness = mean(p1.cachedFitness(NULL));
	varianceFitness = var(p1.cachedFitness(NULL));
	writeFile(Fitness_mean_file_name, paste(meanFitness), append=T);
	writeFile(Fitness_variance_file_name, paste(varianceFitness), append=T);
}

// ensures non-overlaping generations
survival(){

	return (individual.age == 0);
}

mutation(m1) {
	s=mut.selectionCoeff;
	h=runif(1, min=0, max=E^(s*k)); // deleterious mutations have negative s
	mut.setValue("dom", h);
	return T;
}

mutationEffect(m1) {
	if (homozygous)
		return 1.0 + mut.selectionCoeff;
	else
		return 1.0 + mut.getValue("dom") * mut.selectionCoeff;
}

20000 late(){

	sim.simulationFinished();
	allIndividuals=sim.subpopulations.individuals;
	sampledIndividuals=sample(allIndividuals, 50);
	
	sampledIndividuals.genomes.outputVCF(filePath=File_path_i);
	sim.outputFixedMutations(filePath=File_path_f);
}
