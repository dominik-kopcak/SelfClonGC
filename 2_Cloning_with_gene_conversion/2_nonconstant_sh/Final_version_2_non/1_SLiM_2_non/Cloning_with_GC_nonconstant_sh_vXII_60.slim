initialize()
{	
	defineConstant("k", 91.63); // k chosen such that mean h is 0.2
	defineConstant("R", GC_rate);
	defineConstant("MU", 4e-9);
	defineConstant("meanLength", lambda);
	defineConstant("L", 25000000); // for convenience, haploid genome length is defined at the beginning
	
	initializeSLiMModelType("nonWF");
	initializeMutationType("m1", 0, "g", -0.01, 0.2); // 0.01 is the mean, 0.2 is the shape parameter
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	initializeMutationRate(MU); // so that
	initializeRecombinationRate(R); // it actually represent GC, no recombination is heppening
	m1.convertToSubstitution=T;
}

// GC stands for gene conversion: short track on one chromosome which got replaced from another chromosome
// draw of GC tracts length mimics SLiM manual on DSB model of recombination

function (integer)giveGCBreakpoints(void){
	
	GC_number = rpois(1, R*L);
	
	if (GC_number<1){
		
		return integer(0);
	}
	
	else {
		GC_breaks = rdunif(GC_number, 0 , L-1);
		
		GC_left_part = rgeom(GC_number, (-meanLength + sqrt(meanLength)*sqrt(8 + meanLength))/(2*meanLength));
		GC_right_part = rgeom(GC_number, (-meanLength + sqrt(meanLength)*sqrt(8 + meanLength))/(2*meanLength));
		
		GC_track_beginning = GC_breaks - GC_left_part;
		GC_track_end = GC_breaks + GC_right_part;
		
		// removing tracts of zero length
		if (any(GC_track_beginning == GC_track_end)){
			nonzeroLengthIndex = which(GC_track_end-GC_track_beginning > 0);
			GC_track_beginning = GC_track_beginning[nonzeroLengthIndex];
			GC_track_end = GC_track_end[nonzeroLengthIndex];
		}
		
		
		// shifitng tracts with the same beginning
		while (size(unique(GC_track_beginning)) != size(GC_track_beginning)){
			
			uniqueBeginningIndices = match(GC_track_beginning, unique(GC_track_beginning));
			allBeginningIndices =  seq(0, size(uniqueBeginningIndices)-1);
			
			duplicateIndex = whichMin(uniqueBeginningIndices == allBeginningIndices);
			
			GC_track_beginning[duplicateIndex] = GC_track_beginning[duplicateIndex]+1;
		}
		
		
		
		// shifitng tracts with the same end
		while (size(unique(GC_track_end)) != size(GC_track_end)){
			
			uniqueEndIndices = match(GC_track_end, unique(GC_track_end));
			allEndIndices =  seq(0, size(uniqueEndIndices)-1);
			
			duplicateIndex = whichMin(uniqueEndIndices == allEndIndices);
			
			GC_track_end[duplicateIndex] = GC_track_end[duplicateIndex]-1;
		}
		
		
		// removing tracts of zero length resulting from the shifting
		if (any(GC_track_beginning == GC_track_end)){
			nonzeroLengthIndex = which(GC_track_end-GC_track_beginning > 0);
			GC_track_beginning = GC_track_beginning[nonzeroLengthIndex];
			GC_track_end = GC_track_end[nonzeroLengthIndex];
		}
		
		
		// removing breakpoins which are both beginning and end
		xx = match(GC_track_beginning, GC_track_end);
		
		if (any(xx != -1)){
			
			yy = match(GC_track_end, GC_track_beginning);
			
			GC_track_beginning = GC_track_beginning[xx == -1];
			GC_track_end = GC_track_end[yy == -1];
		}
		
		
		
		
		
		
		
		
		
		beginning_order = order(GC_track_beginning); // vector of indices of ordered beginnings
		end_order = order(GC_track_end); // of ordered ends
		
		if ( all(beginning_order == end_order) == F){ // if there is no overlap or nesting, ordering of both beginnigns and ends will be the same, otherwise at least one false is given
			
			beginning_sorted = sort(GC_track_beginning);
			end_sorted = sort(GC_track_end);
			
			
			
			// the crucial is to check if beginnings and ends alternate when put together
			GC_breakpoints_sorted = sort(c(GC_track_beginning, GC_track_end));
			
			beginning_sorted_indices = match(beginning_sorted, GC_breakpoints_sorted);
			end_sorted_indices = match(end_sorted, GC_breakpoints_sorted);
			
			// valid beginnings have even index and valid ends have odd index
			beginning_logical = (integerMod(beginning_sorted_indices, 2) == 0);
			end_logical = (integerMod(end_sorted_indices, 2) == 1);
			
			
			
			while (all(beginning_logical) == F){
				
				GC_track_beginning = beginning_sorted[beginning_logical];
				GC_track_end = end_sorted[end_logical];
				
				// update of variables
				GC_breakpoints_sorted = sort(c(GC_track_beginning, GC_track_end));
				
				beginning_sorted = sort(GC_track_beginning);
				end_sorted = sort(GC_track_end);
				
				beginning_sorted_indices = match(beginning_sorted, GC_breakpoints_sorted);
				end_sorted_indices = match(end_sorted, GC_breakpoints_sorted);
				
				beginning_logical = (integerMod(beginning_sorted_indices, 2) == 0);
				end_logical = (integerMod(end_sorted_indices, 2) == 1);
			}
		}
		
		
		GC_breakpoints = c(GC_track_beginning, GC_track_end);
		
		// removes overrange breakpoints
		inrangeIndex = (GC_breakpoints < L);
		GC_breakpoints = GC_breakpoints[inrangeIndex];
		
		// replaces genuine underrange beginnings by 0
		underrangeIndex = which(GC_breakpoints < 0);
		GC_breakpoints[underrangeIndex] = 0;
	}
	return GC_breakpoints;
}




reproduction(){
	
	K = sim.getValue("K");
	inds = p1.individuals;
	fitness = p1.cachedFitness(NULL);
	parents = sample(inds, K, replace=T, weights=fitness);
	
	for (parent in parents){
		
		if (rdunif(1,0,1)==1){
			
			gA = parent.genome1;
			gB = parent.genome2;
		}
		
		else{
			
			gA = parent.genome2;
			gB = parent.genome1;
		}
		
		GCBreakpoints = giveGCBreakpoints();
		
		p1.addRecombinant(gA, gB, integer(0), gB, gA, GCBreakpoints);
		
		self.active = 0;
	}
}


mutation(m1) {
	s=mut.selectionCoeff;
	h=runif(1, min=0, max=E^(s*k)); // deleterious mutations have negative s
	mut.setValue("dom", h);
	return T;
}

mutationEffect(m1) {
	if (homozygous)
		return 1.0 + mut.selectionCoeff;
	else
		return 1.0 + mut.getValue("dom") * mut.selectionCoeff;
}

1 early(){
	
	seed = getSeed();
	
	print(seed);
	
	sim.setValue("K", 5000);
	sim.addSubpop("p1", sim.getValue("K"));
}

late() {
	
	meanFitness = mean(p1.cachedFitness(NULL));
	varianceFitness = var(p1.cachedFitness(NULL));
	writeFile(Fitness_mean_file_name, paste(meanFitness), append=T);
	writeFile(Fitness_variance_file_name, paste(varianceFitness), append=T);

}

// ensures non-overlaping generations
survival(){
	
	return (individual.age == 0);
}

60000 late(){
	
	sim.simulationFinished();
	allIndividuals=sim.subpopulations.individuals;
	sampledIndividuals=sample(allIndividuals, 50);
	
	sampledIndividuals.genomes.outputVCF(filePath=File_path_i);
	sim.outputFixedMutations(filePath=File_path_f);
}
